import numpy as np
from scipy.io import loadmat
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, confusion_matrix
from sklearn.metrics import pairwise_distances
import matplotlib.pyplot as plt
import seaborn as sns
import os

# Chargement des donn√©es hyperspectrales
def load_salinas(path_X, path_Y):
    X_data = loadmat(path_X)["salinasA_corrected"]
    Y_data = loadmat(path_Y)["salinasA_gt"]
    X = X_data.reshape(-1, X_data.shape[2])
    Y = Y_data.reshape(-1)
    return X, Y

# S√©lection al√©atoire de K points de r√©f√©rence par classe
def select_reference_points(X, Y, K=5):
    classes = np.unique(Y[Y > 0])
    indices = []
    for cls in classes:
        cls_idx = np.where(Y == cls)[0]
        chosen = np.random.choice(cls_idx, K, replace=False)
        indices.extend(chosen)
    return indices

# Construction des matrices de distance
def build_distance_matrices(X, ref_indices, Y, T_labels):
    X_ref = X[ref_indices]
    Dx = pairwise_distances(X, X_ref, metric='euclidean')
    Dy = np.array([[0 if y == tk else 1 for tk in T_labels] for y in Y])
    return Dx, Dy

# Initialisation du mod√®le RLS
def initialize_rls(Dx, Dy):
    P = np.linalg.inv(Dx.T @ Dx + 1e-6 * np.eye(Dx.shape[1]))  # stabilit√© num√©rique
    B = P @ Dx.T @ Dy
    return P, B

# Mise √† jour RLS
def rls_update(Dx_i, Dy_i, P, B):
    Px = P @ Dx_i.T
    S = np.eye(Dx_i.shape[0]) + Dx_i @ Px
    P_new = P - Px @ np.linalg.inv(S) @ Dx_i @ P
    K = P_new @ Dx_i.T
    B_new = B + K @ (Dy_i - Dx_i @ B)
    return P_new, B_new

# Pr√©diction
def predict_label(x, X_ref, B, T_labels):
    dx = pairwise_distances([x], X_ref, metric='euclidean')
    dy = dx @ B
    return T_labels[np.argmin(dy)]

# Fonction principale
def main_rls_pipeline(path_X, path_Y, K_ref=5, test_size=0.2, n_updates=20):
    X, Y = load_salinas(path_X, path_Y)
    mask = Y > 0
    X, Y = X[mask], Y[mask]

    X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=test_size, stratify=Y, random_state=42)

    # Chargement mod√®le s'il existe
    if all(os.path.exists(f) for f in ["model_B.npy", "model_P.npy", "model_ref_points.npy", "model_T_labels.npy"]):
        print("üîÅ Chargement du mod√®le existant...")
        B = np.load("model_B.npy")
        P = np.load("model_P.npy")
        X_ref = np.load("model_ref_points.npy")
        T_labels = np.load("model_T_labels.npy")
    else:
        print("üÜï Initialisation d'un nouveau mod√®le...")
        ref_indices = select_reference_points(X_train, Y_train, K=K_ref)
        X_ref = X_train[ref_indices]
        T_labels = Y_train[ref_indices]
        Dx0, Dy0 = build_distance_matrices(X_train, ref_indices, Y_train, T_labels)
        P, B = initialize_rls(Dx0, Dy0)

    # Mises √† jour r√©cursives
    for _ in range(n_updates):
        idx = np.random.randint(0, len(X_train))
        x_new = X_train[idx:idx+1]
        y_new = Y_train[idx:idx+1]
        Dx_i = pairwise_distances(x_new, X_ref, metric='euclidean')
        Dy_i = np.array([[0 if y_new[0] == tk else 1 for tk in T_labels]])
        P, B = rls_update(Dx_i, Dy_i, P, B)

    # Pr√©dictions
    predictions = [predict_label(x, X_ref, B, T_labels) for x in X_test]
    acc = accuracy_score(Y_test, predictions)
    cm = confusion_matrix(Y_test, predictions, labels=np.unique(Y_test))
    
    print(f"\n‚úÖ Accuracy globale : {acc:.4f}")

    # Affichage de la matrice de confusion
    plt.figure(figsize=(10, 8))
    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', 
                xticklabels=np.unique(Y_test), yticklabels=np.unique(Y_test))
    plt.xlabel("Pr√©dictions")
    plt.ylabel("V√©ritables")
    plt.title("Matrice de confusion - RLS")
    plt.tight_layout()
    plt.show()

    # Sauvegarde du mod√®le
    print("üíæ Sauvegarde du mod√®le...")
    np.save("model_B.npy", B)
    np.save("model_P.npy", P)
    np.save("model_ref_points.npy", X_ref)
    np.save("model_T_labels.npy", T_labels)
    print("‚úÖ Mod√®le sauvegard√©.")

# Lancer le programme
if __name__ == "__main__":
    main_rls_pipeline("ML/SalinasA_corrected.mat", "ML/SalinasA_gt.mat")
